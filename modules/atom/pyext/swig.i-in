namespace IMP {
namespace atom {
%warnfilter(403) ForceFieldParameters;
}
}


IMP_SWIG_DECORATOR(IMP::atom, Atom, Atoms);
IMP_SWIG_DECORATOR(IMP::atom, Residue, Residues);
IMP_SWIG_DECORATOR(IMP::atom, Molecule, Molecules);
IMP_SWIG_DECORATOR(IMP::atom, Fragment, Fragments);
IMP_SWIG_DECORATOR(IMP::atom, Domain, Domains);
IMP_SWIG_DECORATOR(IMP::atom, Chain, Chains);
IMP_SWIG_DECORATOR(IMP::atom, Bond, Bonds);
IMP_SWIG_DECORATOR(IMP::atom, Bonded, Bondeds);
IMP_SWIG_DECORATOR(IMP::atom, Diffusion, Diffusions);
IMP_SWIG_DECORATOR(IMP::atom, Hierarchy, Hierarchies);
IMP_SWIG_DECORATOR(IMP::atom, SimulationParameters, SimulationParameterss);

IMP_SWIG_OBJECT(IMP::atom, VelocityScalingOptimizerState, VelocityScalingOptimizerStates);
IMP_SWIG_VALUE(IMP::atom, AtomType, AtomTypes);
IMP_SWIG_OBJECT(IMP::atom, BondEndpointsRefiner, BondEndpointsRefiners);
IMP_SWIG_OBJECT(IMP::atom, AngleSingletonScore, AngleSingletonScores);
IMP_SWIG_OBJECT(IMP::atom, BondPairContainer, BondPairContainers);
IMP_SWIG_OBJECT(IMP::atom, BondSingletonScore, BondSingletonScores);
IMP_SWIG_OBJECT(IMP::atom, BondedPairFilter, BondedPairFilters);
IMP_SWIG_OBJECT(IMP::atom, MolecularDynamics, MolecularDynamicsList);
IMP_SWIG_OBJECT(IMP::atom, BrownianDynamics, BrownianDynamicsList);
IMP_SWIG_OBJECT(IMP::atom, ForceFieldParameters, ForceFieldParametersList);
IMP_SWIG_DECORATOR(IMP::atom, Charged, Chargeds);
IMP_SWIG_OBJECT(IMP::atom, CoulombPairScore, CoulombPairScores);
IMP_SWIG_OBJECT(IMP::atom, CoverBond, CoverBonds);
IMP_SWIG_DECORATOR(IMP::atom, Dihedral, Dihedrals);
IMP_SWIG_DECORATOR(IMP::atom, Angle, Angles);
IMP_SWIG_OBJECT(IMP::atom, DihedralSingletonScore, DihedralSingletonScores);
IMP_SWIG_OBJECT(IMP::atom, ImproperSingletonScore, ImproperSingletonScores);
IMP_SWIG_OBJECT(IMP::atom, LennardJonesPairScore, LennardJonesPairScores);
IMP_SWIG_OBJECT(IMP::atom, ProteinLigandAtomPairScore, ProteinLigandAtomPairScores);
IMP_SWIG_OBJECT(IMP::atom, ProteinLigandRestraint, ProteinLigandRestraints);
IMP_SWIG_OBJECT(IMP::atom, SmoothingFunction, SmoothingFunctions);
IMP_SWIG_OBJECT(IMP::atom, ForceSwitch, ForceSwitches);
IMP_SWIG_OBJECT(IMP::atom, CHARMMTopology, CHARMMTopologies);
IMP_SWIG_OBJECT(IMP::atom, CHARMMSegmentTopology, CHARMMSegmentTopologies);
IMP_SWIG_OBJECT(IMP::atom, CHARMMResidueTopology, CHARMMResidueTopologies);

IMP_SWIG_BASE_OBJECT(IMP::atom, PDBSelector, PDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, HydrogenPDBSelector,HydrogenPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, Mol2Selector, Mol2Selectors);
IMP_SWIG_OBJECT(IMP::atom, NonAlternativePDBSelector,NonAlternativePDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, NonWaterNonHydrogenPDBSelector,NonWaterNonHydrogenPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, NonWaterPDBSelector,NonWaterPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, NonhydrogenMol2Selector,NonhydrogenMol2Selectors);
IMP_SWIG_OBJECT(IMP::atom, WaterPDBSelector,WaterPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, NotPDBSelector,NotPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, AndPDBSelector,AndPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, OrPDBSelector,OrPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, ATOMPDBSelector, ATOMPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, AllMol2Selector,AllMol2Selectors);
IMP_SWIG_OBJECT(IMP::atom, AllPDBSelector, AllPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, HydrogenPDBSelector, HydrogenPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, NPDBSelector, NPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, NonAlternativePDBSelector, NonAlternativePDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, NonWaterNonHydrogenPDBSelector, NonWaterNonHydrogenPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, NonWaterPDBSelector, NonWaterPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, NonHydrogenMol2Selector, NonHydrogenMol2Selectors);
IMP_SWIG_OBJECT(IMP::atom, PPDBSelector, PPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, CPDBSelector, CPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, ChainPDBSelector, ChainPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, CAlphaPDBSelector, CAlphaPDBSelectors);
IMP_SWIG_OBJECT(IMP::atom, CBetaPDBSelector, CBetaPDBSelectors);
IMP_SWIG_VALUE(IMP::atom, RMSDCalculator, RMSDCalculators);
IMP_SWIG_DECORATOR(IMP::atom, LennardJones, LennardJonesList);
IMP_SWIG_DECORATOR(IMP::atom, CHARMMAtom, CHARMMAtomList);
IMP_SWIG_OBJECT(IMP::atom, StereochemistryPairFilter, StereochemistryPairFilters);

IMP_SWIG_VALUE(IMP::atom, CHARMMIdealResidueTopology, CHARMMIdealResidueTopologies);
IMP_SWIG_VALUE(IMP::atom, CHARMMResidueTopologyBase, CHARMMResidueTopologyBases);
IMP_SWIG_VALUE(IMP::atom, CHARMMPatch, CHARMMPatches);
IMP_SWIG_VALUE(IMP::atom, CHARMMBondParameters, CHARMMBondParametersList);
IMP_SWIG_VALUE(IMP::atom, CHARMMDihedralParameters, CHARMMDihedralParametersList);
IMP_SWIG_VALUE(IMP::atom, CHARMMAtomTopology, CHARMMAtomTopologies);
IMP_SWIG_VALUE(IMP::atom, CHARMMBondEndpoint, CHARMMBondEndpoints);
IMP_SWIG_VALUE(IMP::atom, CHARMMBond, CHARMMBonds);
IMP_SWIG_VALUE(IMP::atom, CHARMMAngle, CHARMMAngles);
IMP_SWIG_VALUE(IMP::atom, CHARMMDihedral, CHARMMDihedrals);
IMP_SWIG_VALUE(IMP::atom, CHARMMInternalCoordinate, CHARMMInternalCoordinates);
IMP_SWIG_OBJECT(IMP::atom, CHARMMParameters, CHARMMParametersList);
IMP_SWIG_OBJECT(IMP::atom, WritePDBOptimizerState, WritePDBOptimizerStates);
IMP_SWIG_OBJECT(IMP::atom, WritePDBFailureHandler, WritePDBFailureHandlers);
IMP_SWIG_VALUE(IMP::atom, Selection, Selections);
IMP_SWIG_VALUE(IMP::atom, ResidueType, ResidueTypes);
IMP_SWIG_DIRECTOR(IMP::atom, PDBSelector);
IMP_SWIG_DECORATOR(IMP::atom, Mass, Masses);

%extend IMP::atom::Selection {
%pythoncode %{
  def __init__(self, hierarchy=None,
                 hierarchies=None,
                 molecules=None,
                 residue_indexes=None,
                 chains=None,
                 atom_types=None,
                 residue_types=None,
                 domains=None,
                 target_radius=-1,
                 molecule=None,
                 residue_index=None,
                 chain=None,
                 atom_type=None,
                 residue_type=None,
                 terminus=None,
                 domain=None):
      if hierarchy:
        this = _IMP_atom.new_Selection(hierarchy)
        try: self.this.append(this)
        except: self.this = this
      else:
        this = _IMP_atom.new_Selection(hierarchies)
        try: self.this.append(this)
        except: self.this = this
      if not molecules:
          molecules=[]
      if not residue_indexes:
          residue_indexes=[]
      if not chains:
          chains=[]
      if not atom_types:
          atom_types=[]
      if not residue_types:
          residue_types=[]
      if not domains:
          domains=[]
      if molecule:
         molecules.append(molecule)
      if residue_index:
         residue_indexes.append(residue_index)
      if chain:
         chains.append(chain)
      if atom_type:
         atom_types.append(atom_type)
      if residue_type:
         residue_types.append(residue_type)
      if domain:
         domains.append(domain)
      if terminus:
         self.set_terminus(terminus)
      presidue_indexes=[]
      for ri in residue_indexes:
         if type(ri) == type(()):
             presidue_indexes= presidue_indexes+ range(ri[0], ri[1])
         else:
             presidue_indexes.append(ri)
      self.set_molecules(molecules);
      self.set_chains("".join(chains));
      self.set_residue_indexes(presidue_indexes);
      self.set_atom_types(atom_types);
      self.set_residue_types(residue_types);
      self.set_domains(domains);
      self.set_target_radius(target_radius);
%}
}

%include "IMP/atom/atom_macros.h"

// must be before hierarchy
%include "IMP/atom/bond_decorators.h"

// it is used as a base class
%include "IMP/atom/Hierarchy.h"


/* Wrap our own classes */
%include "IMP/atom/angle_decorators.h"
%include "IMP/atom/distance.h"
%include "IMP/atom/smoothing_functions.h"
%include "IMP/atom/AngleSingletonScore.h"
%include "IMP/atom/BondEndpointsRefiner.h"
%include "IMP/atom/BondPairContainer.h"
%include "IMP/atom/BondSingletonScore.h"
%include "IMP/atom/DihedralSingletonScore.h"
%include "IMP/atom/ImproperSingletonScore.h"
%include "IMP/atom/CoverBond.h"
%include "IMP/atom/BrownianDynamics.h"
%include "IMP/atom/Diffusion.h"
%include "IMP/atom/Chain.h"
%include "IMP/atom/Charged.h"
%include "IMP/atom/CoulombPairScore.h"
%include "IMP/atom/Domain.h"
%include "IMP/atom/LennardJones.h"
%include "IMP/atom/LennardJonesPairScore.h"
%include "IMP/atom/MolecularDynamics.h"
%include "IMP/atom/VelocityScalingOptimizerState.h"
%include "IMP/atom/Fragment.h"
%include "IMP/atom/SimulationParameters.h"
%include "IMP/atom/StereochemistryPairFilter.h"
%include "IMP/atom/Mass.h"
%include "IMP/atom/BondedPairFilter.h"
%include "IMP/atom/mol2.h"

namespace IMP {
  namespace atom {
   %template(_ProteinLigandAtomPairScoreBase) ::IMP::core::StatisticalPairScore< IMP::atom::ProteinLigandType, true, false>;
  }
}
%include "IMP/atom/protein_ligand_score.h"

namespace IMP {
  namespace atom {
   // swig has random, perplexing issues if these are higher in the file
   %template(AtomType) ::IMP::Key<IMP_ATOM_TYPE_INDEX, false>;
   %template(ResidueType) ::IMP::Key<IMP_RESIDUE_TYPE_INDEX, true>;
  }
}
%include "IMP/atom/element.h"
%include "IMP/atom/Atom.h"
%include "IMP/atom/Residue.h"
%include "IMP/atom/Molecule.h"
%include "IMP/atom/ForceFieldParameters.h"
%include "IMP/atom/charmm_topology.h"
%include "IMP/atom/CHARMMAtom.h"
%include "IMP/atom/CHARMMParameters.h"
%include "IMP/atom/force_fields.h"
%include "IMP/atom/estimates.h"
%include "IMP/atom/pdb.h"
%include "IMP/atom/hierarchy_tools.h"

namespace IMP {
  namespace atom {
   %template(show_molecular_hierarchy) IMP::core::show<IMP::atom::Hierarchy>;
   %template(CHARMMBond) CHARMMConnection<2>;
   %template(CHARMMAngle) CHARMMConnection<3>;
   %template(_get_rmsd_cpp) get_rmsd<std::vector<algebra::VectorD<3> >, std::vector<algebra::VectorD<3> > >;
   %template(_get_native_overlap_cpp) get_native_overlap<std::vector<algebra::VectorD<3> >, std::vector<algebra::VectorD<3> > >;
  }
}

%pythoncode %{
def get_rmsd(a, b):
   va= [IMP.algebra.get_vector(x) for x in a]
   vb= [IMP.algebra.get_vector(x) for x in b]
   return _get_rmsd_cpp(va, vb)
def get_native_overlap(a, b, d):
   va= [IMP.algebra.get_vector(x) for x in a]
   vb= [IMP.algebra.get_vector(x) for x in b]
   return _get_native_overlap_cpp(va, vb, d)
%}
